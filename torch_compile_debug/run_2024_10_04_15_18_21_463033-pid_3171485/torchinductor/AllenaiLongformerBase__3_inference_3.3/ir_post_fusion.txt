op0: ExternKernelSchedulerNode(ExternKernelOut)
op0.writes = [StarDep(name='buf0', mode=None)]
op0.unmet_dependencies = []
op0.met_dependencies = [StarDep(name='arg0_1', mode=None), StarDep(name='arg1_1', mode=None)]
op0.outputs = [
    buf0: ExternKernelOut
    buf0.layout = FixedLayout('cuda', torch.float32, size=[4096, 768], stride=[768, 1])
    buf0.users = [
        NodeUser(node=SchedulerNode(name='op1'), can_inplace=False, is_weak=False),
        NodeUser(node=SchedulerNode(name='op2'), can_inplace=False, is_weak=False),
        NodeUser(node=SchedulerNode(name='op3'), can_inplace=False, is_weak=False),
        NodeUser(node=SchedulerNode(name='op4'), can_inplace=True, is_weak=False),
    ]
]
op0.node.kernel = extern_kernels.mm


op1_op2_op4: FusedSchedulerNode(SchedulerNode,SchedulerNode,SchedulerNode)
op1_op2_op4.writes = 
    [   MemoryDep('buf1', c0, {c0: 4096}, None),
        MemoryDep('buf2', c0, {c0: 4096}, None),
        MemoryDep('buf4', c0, {c0: 3145728}, None)]
op1_op2_op4.unmet_dependencies = [MemoryDep('buf0', c0, {c0: 3145728}, None)]
op1_op2_op4.met_dependencies = 
    [   MemoryDep('arg2_1', c1, {c0: 4096, c1: 768}, None),
        MemoryDep('arg3_1', c1, {c0: 4096, c1: 768}, None),
        MemoryDep('arg4_1', c1, {c0: 4096, c1: 768}, None)]
op1_op2_op4.outputs = [
    buf1: ComputedBuffer
    buf1.layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
    buf1.users = [NodeUser(node=SchedulerNode(name='op4'), can_inplace=False, is_weak=False)]
    buf2: ComputedBuffer
    buf2.layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
    buf2.users = [NodeUser(node=SchedulerNode(name='op4'), can_inplace=False, is_weak=False)]
    buf4: ComputedBuffer
    buf4.layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 768], stride=[786432, 768, 1])
    buf4.users = [NodeUser(node=ExternKernelSchedulerNode(name='op7'), can_inplace=False, is_weak=False)]
]
op1_op2_op4.snodes[0] =
op1: SchedulerNode(ComputedBuffer)
op1.writes = [MemoryDep('buf1', c0, {c0: 4096}, None)]
op1.unmet_dependencies = [MemoryDep('buf0', c0, {c0: 3145728}, None)]
op1.met_dependencies = [MemoryDep('arg2_1', c1, {c0: 4096, c1: 768}, None)]
op1.outputs = [
    buf1: ComputedBuffer
    buf1.layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
    buf1.users = [NodeUser(node=SchedulerNode(name='op4'), can_inplace=False, is_weak=False)]
]
op1.group.device = cuda:0
op1.group.iteration = (4096, 768)
op1.sizes = ([4096], [768])
buf0_layout = FixedLayout('cuda', torch.float32, size=[4096, 768], stride=[768, 1])
arg2_1_layout = FixedLayout('cuda', torch.float32, size=[768], stride=[1])
buf1_layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
class op1_loop_body:
    var_ranges = {z0: 4096, z1: 768}
    index0 = 768*z0 + z1
    index1 = z1
    index2 = z0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('buf0', get_index)
        get_index_1 = self.get_index('index1')
        load_1 = ops.load('arg2_1', get_index_1)
        add = ops.add(load, load_1)
        constant = ops.constant(0.5, torch.float32)
        mul = ops.mul(add, constant)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('buf0', get_index_2)
        get_index_3 = self.get_index('index1')
        load_3 = ops.load('arg2_1', get_index_3)
        add_1 = ops.add(load_2, load_3)
        constant_1 = ops.constant(0.7071067811865476, torch.float32)
        mul_1 = ops.mul(add_1, constant_1)
        erf = ops.erf(mul_1)
        constant_2 = ops.constant(1.0, torch.float32)
        add_2 = ops.add(erf, constant_2)
        mul_2 = ops.mul(mul, add_2)
        reduction = ops.reduction(torch.float32, torch.float32, 'welford_reduce', mul_2)
        getitem = reduction[0]
        getitem_1 = reduction[1]
        getitem_2 = reduction[2]
        get_index_4 = self.get_index('index2')
        store_reduction = ops.store_reduction('buf1', get_index_4, getitem)
        return store_reduction
op1 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.persistent_reduction(
        size_hints=[4096, 1024],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: '*fp32', 3: 'i32', 4: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3, 4), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': True, 'num_load': 2, 'num_reduction': 3, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, in_ptr1, out_ptr0, xnumel, rnumel):
        xnumel = 4096
        XBLOCK: tl.constexpr = 1
        rnumel = 768
        RBLOCK: tl.constexpr = 1024
        xoffset = tl.program_id(0) * XBLOCK
        xindex = tl.full([1], xoffset, tl.int32)
        xmask = tl.full([RBLOCK], True, tl.int1)
        rindex = tl.arange(0, RBLOCK)[:]
        roffset = 0
        rmask = rindex < rnumel
        r1 = rindex
        x0 = xindex
        tmp0 = tl.load(in_ptr0 + (r1 + (768*x0)), rmask, other=0.0)
        tmp1 = tl.load(in_ptr1 + (r1), rmask, eviction_policy='evict_last', other=0.0)
        tmp2 = tmp0 + tmp1
        tmp3 = 0.5
        tmp4 = tmp2 * tmp3
        tmp5 = 0.7071067811865476
        tmp6 = tmp2 * tmp5
        tmp7 = libdevice.erf(tmp6)
        tmp8 = 1.0
        tmp9 = tmp7 + tmp8
        tmp10 = tmp4 * tmp9
        tmp11 = tl.broadcast_to(tmp10, [RBLOCK])
        tmp13 = tl.where(rmask, tmp11, 0)
        tmp14 = tl.broadcast_to(tmp11, [RBLOCK])
        tmp16 = tl.where(rmask, tmp14, 0)
        tmp17 = triton_helpers.promote_to_tensor(tl.sum(tmp16, 0))
        tmp18 = tl.full([1], 768, tl.int32)
        tmp19 = tmp18.to(tl.float32)
        tmp20 = tmp17 / tmp19
        tmp21 = tmp11 - tmp20
        tmp22 = tmp21 * tmp21
        tmp23 = tl.broadcast_to(tmp22, [RBLOCK])
        tmp25 = tl.where(rmask, tmp23, 0)
        tmp26 = triton_helpers.promote_to_tensor(tl.sum(tmp25, 0))
        tl.store(out_ptr0 + (x0), tmp20, None)
op1_op2_op4.snodes[1] =
op2: SchedulerNode(ComputedBuffer)
op2.writes = [MemoryDep('buf2', c0, {c0: 4096}, None)]
op2.unmet_dependencies = [MemoryDep('buf0', c0, {c0: 3145728}, None)]
op2.met_dependencies = [MemoryDep('arg2_1', c1, {c0: 4096, c1: 768}, None)]
op2.outputs = [
    buf2: ComputedBuffer
    buf2.layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
    buf2.users = [NodeUser(node=SchedulerNode(name='op4'), can_inplace=False, is_weak=False)]
]
op2.group.device = cuda:0
op2.group.iteration = (4096, 768)
op2.sizes = ([4096], [768])
buf0_layout = FixedLayout('cuda', torch.float32, size=[4096, 768], stride=[768, 1])
arg2_1_layout = FixedLayout('cuda', torch.float32, size=[768], stride=[1])
buf2_layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
class op2_loop_body:
    var_ranges = {z0: 4096, z1: 768}
    index0 = 768*z0 + z1
    index1 = z1
    index2 = z0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('buf0', get_index)
        get_index_1 = self.get_index('index1')
        load_1 = ops.load('arg2_1', get_index_1)
        add = ops.add(load, load_1)
        constant = ops.constant(0.5, torch.float32)
        mul = ops.mul(add, constant)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('buf0', get_index_2)
        get_index_3 = self.get_index('index1')
        load_3 = ops.load('arg2_1', get_index_3)
        add_1 = ops.add(load_2, load_3)
        constant_1 = ops.constant(0.7071067811865476, torch.float32)
        mul_1 = ops.mul(add_1, constant_1)
        erf = ops.erf(mul_1)
        constant_2 = ops.constant(1.0, torch.float32)
        add_2 = ops.add(erf, constant_2)
        mul_2 = ops.mul(mul, add_2)
        reduction = ops.reduction(torch.float32, torch.float32, 'welford_reduce', mul_2)
        getitem = reduction[0]
        getitem_1 = reduction[1]
        getitem_2 = reduction[2]
        get_index_4 = self.get_index('index2')
        store_reduction = ops.store_reduction('buf2', get_index_4, getitem_1)
        return store_reduction
op2 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.persistent_reduction(
        size_hints=[4096, 1024],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: '*fp32', 3: 'i32', 4: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3, 4), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': True, 'num_load': 2, 'num_reduction': 3, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, in_ptr1, out_ptr0, xnumel, rnumel):
        xnumel = 4096
        XBLOCK: tl.constexpr = 1
        rnumel = 768
        RBLOCK: tl.constexpr = 1024
        xoffset = tl.program_id(0) * XBLOCK
        xindex = tl.full([1], xoffset, tl.int32)
        xmask = tl.full([RBLOCK], True, tl.int1)
        rindex = tl.arange(0, RBLOCK)[:]
        roffset = 0
        rmask = rindex < rnumel
        r1 = rindex
        x0 = xindex
        tmp0 = tl.load(in_ptr0 + (r1 + (768*x0)), rmask, other=0.0)
        tmp1 = tl.load(in_ptr1 + (r1), rmask, eviction_policy='evict_last', other=0.0)
        tmp2 = tmp0 + tmp1
        tmp3 = 0.5
        tmp4 = tmp2 * tmp3
        tmp5 = 0.7071067811865476
        tmp6 = tmp2 * tmp5
        tmp7 = libdevice.erf(tmp6)
        tmp8 = 1.0
        tmp9 = tmp7 + tmp8
        tmp10 = tmp4 * tmp9
        tmp11 = tl.broadcast_to(tmp10, [RBLOCK])
        tmp13 = tl.where(rmask, tmp11, 0)
        tmp14 = tl.broadcast_to(tmp11, [RBLOCK])
        tmp16 = tl.where(rmask, tmp14, 0)
        tmp17 = triton_helpers.promote_to_tensor(tl.sum(tmp16, 0))
        tmp18 = tl.full([1], 768, tl.int32)
        tmp19 = tmp18.to(tl.float32)
        tmp20 = tmp17 / tmp19
        tmp21 = tmp11 - tmp20
        tmp22 = tmp21 * tmp21
        tmp23 = tl.broadcast_to(tmp22, [RBLOCK])
        tmp25 = tl.where(rmask, tmp23, 0)
        tmp26 = triton_helpers.promote_to_tensor(tl.sum(tmp25, 0))
        tl.store(out_ptr0 + (x0), tmp26, None)
op1_op2_op4.snodes[2] =
op4: SchedulerNode(ComputedBuffer)
op4.writes = [MemoryDep('buf4', c0, {c0: 3145728}, None)]
op4.unmet_dependencies = 
    [   MemoryDep('buf0', c0, {c0: 3145728}, None),
        MemoryDep('buf1', c0, {c0: 4096}, None),
        MemoryDep('buf2', c0, {c0: 4096}, None)]
op4.met_dependencies = 
    [   MemoryDep('arg2_1', c1, {c0: 4096, c1: 768}, None),
        MemoryDep('arg3_1', c1, {c0: 4096, c1: 768}, None),
        MemoryDep('arg4_1', c1, {c0: 4096, c1: 768}, None)]
op4.outputs = [
    buf4: ComputedBuffer
    buf4.layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 768], stride=[786432, 768, 1])
    buf4.users = [NodeUser(node=ExternKernelSchedulerNode(name='op7'), can_inplace=False, is_weak=False)]
]
op4.group.device = cuda:0
op4.group.iteration = (3145728, 1)
op4.sizes = ([4096, 768], [])
buf0_layout = FixedLayout('cuda', torch.float32, size=[4096, 768], stride=[768, 1])
arg2_1_layout = FixedLayout('cuda', torch.float32, size=[768], stride=[1])
buf1_layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
buf2_layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 1], stride=[1024, 1, 4096])
arg3_1_layout = FixedLayout('cuda', torch.float32, size=[768], stride=[1])
arg4_1_layout = FixedLayout('cuda', torch.float32, size=[768], stride=[1])
buf4_layout = FixedLayout('cuda', torch.float32, size=[4, 1024, 768], stride=[786432, 768, 1])
class op4_loop_body:
    var_ranges = {z0: 4096, z1: 768}
    index0 = 768*z0 + z1
    index1 = z1
    index2 = z0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('buf0', get_index)
        get_index_1 = self.get_index('index1')
        load_1 = ops.load('arg2_1', get_index_1)
        add = ops.add(load, load_1)
        constant = ops.constant(0.5, torch.float32)
        mul = ops.mul(add, constant)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('buf0', get_index_2)
        get_index_3 = self.get_index('index1')
        load_3 = ops.load('arg2_1', get_index_3)
        add_1 = ops.add(load_2, load_3)
        constant_1 = ops.constant(0.7071067811865476, torch.float32)
        mul_1 = ops.mul(add_1, constant_1)
        erf = ops.erf(mul_1)
        constant_2 = ops.constant(1.0, torch.float32)
        add_2 = ops.add(erf, constant_2)
        mul_2 = ops.mul(mul, add_2)
        get_index_4 = self.get_index('index2')
        load_4 = ops.load('buf1', get_index_4)
        sub = ops.sub(mul_2, load_4)
        get_index_5 = self.get_index('index2')
        load_5 = ops.load('buf2', get_index_5)
        constant_3 = ops.constant(768.0, torch.float32)
        truediv = ops.truediv(load_5, constant_3)
        constant_4 = ops.constant(1e-05, torch.float32)
        add_3 = ops.add(truediv, constant_4)
        rsqrt = ops.rsqrt(add_3)
        mul_3 = ops.mul(sub, rsqrt)
        get_index_6 = self.get_index('index1')
        load_6 = ops.load('arg3_1', get_index_6)
        mul_4 = ops.mul(mul_3, load_6)
        get_index_7 = self.get_index('index1')
        load_7 = ops.load('arg4_1', get_index_7)
        add_4 = ops.add(mul_4, load_7)
        get_index_8 = self.get_index('index0')
        store = ops.store('buf4', get_index_8, add_4, None)
        return store
op4 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.pointwise(
        size_hints=[4194304], 
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: '*fp32', 3: '*fp32', 4: '*fp32', 5: '*fp32', 6: '*fp32', 7: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3, 4, 5, 6, 7), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 6, 'num_reduction': 0, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False},
        min_elem_per_thread=0
    )
    @triton.jit
    def triton_(in_ptr0, in_ptr1, in_ptr2, in_ptr3, in_ptr4, in_ptr5, out_ptr0, xnumel, XBLOCK : tl.constexpr):
        xnumel = 3145728
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:]
        xmask = tl.full([XBLOCK], True, tl.int1)
        x2 = xindex
        x0 = xindex % 768
        x1 = (xindex // 768)
        tmp0 = tl.load(in_ptr0 + (x2), None)
        tmp1 = tl.load(in_ptr1 + (x0), None, eviction_policy='evict_last')
        tmp11 = tl.load(in_ptr2 + (x1), None, eviction_policy='evict_last')
        tmp13 = tl.load(in_ptr3 + (x1), None, eviction_policy='evict_last')
        tmp20 = tl.load(in_ptr4 + (x0), None, eviction_policy='evict_last')
        tmp22 = tl.load(in_ptr5 + (x0), None, eviction_policy='evict_last')
        tmp2 = tmp0 + tmp1
        tmp3 = 0.5
        tmp4 = tmp2 * tmp3
        tmp5 = 0.7071067811865476
        tmp6 = tmp2 * tmp5
        tmp7 = libdevice.erf(tmp6)
        tmp8 = 1.0
        tmp9 = tmp7 + tmp8
        tmp10 = tmp4 * tmp9
        tmp12 = tmp10 - tmp11
        tmp14 = 768.0
        tmp15 = tmp13 / tmp14
        tmp16 = 1e-05
        tmp17 = tmp15 + tmp16
        tmp18 = libdevice.rsqrt(tmp17)
        tmp19 = tmp12 * tmp18
        tmp21 = tmp19 * tmp20
        tmp23 = tmp21 + tmp22
        tl.store(out_ptr0 + (x2), tmp23, None)
op1_op2_op4 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.persistent_reduction(
        size_hints=[4096, 1024],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: '*fp32', 3: '*fp32', 4: '*fp32', 5: 'i32', 6: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3, 4, 5, 6), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': True, 'num_load': 4, 'num_reduction': 4, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, in_ptr1, in_ptr2, in_ptr3, out_ptr2, xnumel, rnumel):
        xnumel = 4096
        XBLOCK: tl.constexpr = 1
        rnumel = 768
        RBLOCK: tl.constexpr = 1024
        xoffset = tl.program_id(0) * XBLOCK
        xindex = tl.full([1], xoffset, tl.int32)
        xmask = tl.full([RBLOCK], True, tl.int1)
        rindex = tl.arange(0, RBLOCK)[:]
        roffset = 0
        rmask = rindex < rnumel
        r1 = rindex
        x0 = xindex
        tmp0 = tl.load(in_ptr0 + (r1 + (768*x0)), rmask, other=0.0)
        tmp1 = tl.load(in_ptr1 + (r1), rmask, eviction_policy='evict_last', other=0.0)
        tmp34 = tl.load(in_ptr2 + (r1), rmask, eviction_policy='evict_last', other=0.0)
        tmp36 = tl.load(in_ptr3 + (r1), rmask, eviction_policy='evict_last', other=0.0)
        tmp2 = tmp0 + tmp1
        tmp3 = 0.5
        tmp4 = tmp2 * tmp3
        tmp5 = 0.7071067811865476
        tmp6 = tmp2 * tmp5
        tmp7 = libdevice.erf(tmp6)
        tmp8 = 1.0
        tmp9 = tmp7 + tmp8
        tmp10 = tmp4 * tmp9
        tmp11 = tl.broadcast_to(tmp10, [RBLOCK])
        tmp13 = tl.where(rmask, tmp11, 0)
        tmp14 = tl.broadcast_to(tmp11, [RBLOCK])
        tmp16 = tl.where(rmask, tmp14, 0)
        tmp17 = triton_helpers.promote_to_tensor(tl.sum(tmp16, 0))
        tmp18 = tl.full([1], 768, tl.int32)
        tmp19 = tmp18.to(tl.float32)
        tmp20 = tmp17 / tmp19
        tmp21 = tmp11 - tmp20
        tmp22 = tmp21 * tmp21
        tmp23 = tl.broadcast_to(tmp22, [RBLOCK])
        tmp25 = tl.where(rmask, tmp23, 0)
        tmp26 = triton_helpers.promote_to_tensor(tl.sum(tmp25, 0))
        tmp27 = tmp10 - tmp20
        tmp28 = 768.0
        tmp29 = tmp26 / tmp28
        tmp30 = 1e-05
        tmp31 = tmp29 + tmp30
        tmp32 = libdevice.rsqrt(tmp31)
        tmp33 = tmp27 * tmp32
        tmp35 = tmp33 * tmp34
        tmp37 = tmp35 + tmp36
        tl.store(out_ptr2 + (r1 + (768*x0)), tmp37, rmask)


op5: SchedulerNode(ComputedBuffer)
op5.writes = [MemoryDep('buf5', 50272*c0 + c1, {c0: 768, c1: 50268}, None)]
op5.unmet_dependencies = []
op5.met_dependencies = [MemoryDep('arg5_1', c0 + 768*I, {c0: 768, c1: 50268}, None)]
op5.outputs = [
    buf5: ComputedBuffer
    buf5.layout = FixedLayout('cuda', torch.float32, size=[768, 50268], stride=[50272, 1])
    buf5.users = [NodeUser(node=ExternKernelSchedulerNode(name='op7'), can_inplace=False, is_weak=False)]
]
op5.group.device = cuda:0
op5.group.iteration = (38605824, 1)
op5.sizes = ([768, 50268], [])
arg5_1_layout = FixedLayout('cuda', torch.float32, size=[50265, 768], stride=[768, 1])
buf5_layout = FixedLayout('cuda', torch.float32, size=[768, 50268], stride=[50272, 1])
class op5_loop_body:
    var_ranges = {z0: 768, z1: 50268}
    index0 = z1
    index1 = z0 + 768*I
    index2 = 50272*z0 + z1
    def body(self, ops):
        get_index = self.get_index('index0')
        index_expr = ops.index_expr(get_index, torch.int64)
        constant = ops.constant(0, torch.int64)
        ge = ops.ge(index_expr, constant)
        get_index_1 = self.get_index('index0')
        index_expr_1 = ops.index_expr(get_index_1, torch.int64)
        constant_1 = ops.constant(50265, torch.int64)
        lt = ops.lt(index_expr_1, constant_1)
        masked_subblock1 = self.masked_subblock1(lt, 0.0)
        get_index_2 = self.get_index('index0')
        index_expr_2 = ops.index_expr(get_index_2, torch.int64)
        constant_2 = ops.constant(50265, torch.int64)
        ge_1 = ops.ge(index_expr_2, constant_2)
        get_index_3 = self.get_index('index0')
        index_expr_3 = ops.index_expr(get_index_3, torch.int64)
        constant_3 = ops.constant(50268, torch.int64)
        lt_1 = ops.lt(index_expr_3, constant_3)
        masked_subblock2 = self.masked_subblock2(ge_1, 0.0)
        where = ops.where(lt, masked_subblock1, masked_subblock2)
        get_index_4 = self.get_index('index2')
        store = ops.store('buf5', get_index_4, where, None)
        return store
    def masked_subblock1(self, ops):
        get_index = self.get_index('index1')
        load = ops.load('arg5_1', get_index)
        return load
    def masked_subblock2(self, ops):
        constant = ops.constant(0.0, torch.float32)
        return constant
op5 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.pointwise(
        size_hints=[67108864], 
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 1, 'num_reduction': 0, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False},
        min_elem_per_thread=0
    )
    @triton.jit
    def triton_(in_ptr0, out_ptr0, xnumel, XBLOCK : tl.constexpr):
        xnumel = 38605824
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:]
        xmask = xindex < xnumel
        x0 = xindex % 50268
        x1 = (xindex // 50268)
        tmp0 = x0
        tmp1 = tl.full([1], 0, tl.int64)
        tmp2 = tmp0 >= tmp1
        tmp3 = tl.full([1], 50265, tl.int64)
        tmp4 = tmp0 < tmp3
        tmp5 = tl.load(in_ptr0 + (x1 + (768*x0)), tmp4 & xmask, eviction_policy='evict_last', other=0.0)
        tmp6 = tmp0 >= tmp3
        tmp7 = tl.full([1], 50268, tl.int64)
        tmp8 = tmp0 < tmp7
        tmp9 = 0.0
        tmp10 = tl.full(tmp9.shape, 0.0, tmp9.dtype)
        tmp11 = tl.where(tmp6, tmp9, tmp10)
        tmp12 = tl.where(tmp4, tmp5, tmp11)
        tl.store(out_ptr0 + (x0 + (50272*x1)), tmp12, xmask)


op6: SchedulerNode(ComputedBuffer)
op6.writes = [MemoryDep('buf6', c0, {c0: 50268}, None)]
op6.unmet_dependencies = []
op6.met_dependencies = [MemoryDep('arg6_1', I, {c0: 50268}, None)]
op6.outputs = [
    buf6: ComputedBuffer
    buf6.layout = FixedLayout('cuda', torch.float32, size=[50268], stride=[1])
    buf6.users = [NodeUser(node=ExternKernelSchedulerNode(name='op7'), can_inplace=False, is_weak=False)]
]
op6.group.device = cuda:0
op6.group.iteration = (50268, 1)
op6.sizes = ([50268], [])
arg6_1_layout = FixedLayout('cuda', torch.float32, size=[50265], stride=[1])
buf6_layout = FixedLayout('cuda', torch.float32, size=[50268], stride=[1])
class op6_loop_body:
    var_ranges = {z0: 50268}
    index0 = z0
    index1 = I
    def body(self, ops):
        get_index = self.get_index('index0')
        index_expr = ops.index_expr(get_index, torch.int64)
        constant = ops.constant(0, torch.int64)
        ge = ops.ge(index_expr, constant)
        get_index_1 = self.get_index('index0')
        index_expr_1 = ops.index_expr(get_index_1, torch.int64)
        constant_1 = ops.constant(50265, torch.int64)
        lt = ops.lt(index_expr_1, constant_1)
        masked_subblock1 = self.masked_subblock1(lt, 0.0)
        get_index_2 = self.get_index('index0')
        index_expr_2 = ops.index_expr(get_index_2, torch.int64)
        constant_2 = ops.constant(50265, torch.int64)
        ge_1 = ops.ge(index_expr_2, constant_2)
        get_index_3 = self.get_index('index0')
        index_expr_3 = ops.index_expr(get_index_3, torch.int64)
        constant_3 = ops.constant(50268, torch.int64)
        lt_1 = ops.lt(index_expr_3, constant_3)
        masked_subblock2 = self.masked_subblock2(ge_1, 0.0)
        where = ops.where(lt, masked_subblock1, masked_subblock2)
        get_index_4 = self.get_index('index0')
        store = ops.store('buf6', get_index_4, where, None)
        return store
    def masked_subblock1(self, ops):
        get_index = self.get_index('index1')
        load = ops.load('arg6_1', get_index)
        return load
    def masked_subblock2(self, ops):
        constant = ops.constant(0.0, torch.float32)
        return constant
op6 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.pointwise(
        size_hints=[65536], 
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 1, 'num_reduction': 0, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False},
        min_elem_per_thread=0
    )
    @triton.jit
    def triton_(in_ptr0, out_ptr0, xnumel, XBLOCK : tl.constexpr):
        xnumel = 50268
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:]
        xmask = xindex < xnumel
        x0 = xindex
        tmp0 = x0
        tmp1 = tl.full([1], 0, tl.int64)
        tmp2 = tmp0 >= tmp1
        tmp3 = tl.full([1], 50265, tl.int64)
        tmp4 = tmp0 < tmp3
        tmp5 = tl.load(in_ptr0 + (x0), tmp4 & xmask, eviction_policy='evict_last', other=0.0)
        tmp6 = tmp0 >= tmp3
        tmp7 = tl.full([1], 50268, tl.int64)
        tmp8 = tmp0 < tmp7
        tmp9 = 0.0
        tmp10 = tl.full(tmp9.shape, 0.0, tmp9.dtype)
        tmp11 = tl.where(tmp6, tmp9, tmp10)
        tmp12 = tl.where(tmp4, tmp5, tmp11)
        tl.store(out_ptr0 + (x0), tmp12, xmask)


op7: ExternKernelSchedulerNode(ExternKernelOut)
op7.writes = [StarDep(name='buf7', mode=None)]
op7.unmet_dependencies = 
    [   StarDep(name='buf4', mode=None),
        StarDep(name='buf5', mode=None),
        StarDep(name='buf6', mode=None)]
op7.met_dependencies = []
op7.outputs = [
    buf7: ExternKernelOut
    buf7.layout = FixedLayout('cuda', torch.float32, size=[4096, 50268], stride=[50272, 1])
    buf7.users = [
        NodeUser(node=SchedulerNode(name='op8'), can_inplace=False, is_weak=False),
        NodeUser(node=SchedulerNode(name='op9'), can_inplace=False, is_weak=False),
        NodeUser(node=SchedulerNode(name='op10'), can_inplace=False, is_weak=False),
        NodeUser(node=OUTPUT, can_inplace=False, is_weak=False),
    ]
]
op7.node.kernel = extern_kernels.addmm


op8_op9: FusedSchedulerNode(SchedulerNode,SchedulerNode)
op8_op9.writes = 
    [   MemoryDep('buf8', c0, {c0: 4096}, None),
        MemoryDep('buf9', c0, {c0: 4096}, None)]
op8_op9.unmet_dependencies = [MemoryDep('buf7', 50272*c0 + c1, {c0: 4096, c1: 50265}, None)]
op8_op9.met_dependencies = []
op8_op9.outputs = [
    buf8: ComputedBuffer
    buf8.layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
    buf8.users = [
        NodeUser(node=SchedulerNode(name='op9'), can_inplace=True, is_weak=False),
        NodeUser(node=SchedulerNode(name='op10'), can_inplace=False, is_weak=False),
    ]
    buf9: ComputedBuffer
    buf9.layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
    buf9.users = [NodeUser(node=SchedulerNode(name='op10'), can_inplace=False, is_weak=False)]
]
op8_op9.snodes[0] =
op8: SchedulerNode(ComputedBuffer)
op8.writes = [MemoryDep('buf8', c0, {c0: 4096}, None)]
op8.unmet_dependencies = [MemoryDep('buf7', 50272*c0 + c1, {c0: 4096, c1: 50265}, None)]
op8.met_dependencies = []
op8.outputs = [
    buf8: ComputedBuffer
    buf8.layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
    buf8.users = [
        NodeUser(node=SchedulerNode(name='op9'), can_inplace=True, is_weak=False),
        NodeUser(node=SchedulerNode(name='op10'), can_inplace=False, is_weak=False),
    ]
]
op8.group.device = cuda:0
op8.group.iteration = (4096, 50265)
op8.sizes = ([4096], [50265])
buf7_layout = FixedLayout('cuda', torch.float32, size=[4096, 50268], stride=[50272, 1])
buf8_layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
class op8_loop_body:
    var_ranges = {z0: 4096, z1: 50265}
    index0 = 50272*z0 + z1
    index1 = z0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('buf7', get_index)
        reduction = ops.reduction(torch.float32, torch.float32, 'max', load)
        get_index_1 = self.get_index('index1')
        store_reduction = ops.store_reduction('buf8', get_index_1, reduction)
        return store_reduction
op8 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.reduction(
        size_hints=[4096, 65536],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: 'i32', 3: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 1, 'num_reduction': 1, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, out_ptr0, xnumel, rnumel, XBLOCK : tl.constexpr, RBLOCK : tl.constexpr):
        xnumel = 4096
        rnumel = 50265
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
        xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
        rbase = tl.arange(0, RBLOCK)[None, :]
        x0 = xindex
        _tmp2 = tl.full([XBLOCK, RBLOCK], float("-inf"), tl.float32)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r1 = rindex
            tmp0 = tl.load(in_ptr0 + (r1 + (50272*x0)), rmask, eviction_policy='evict_last', other=0.0)
            tmp1 = tl.broadcast_to(tmp0, [XBLOCK, RBLOCK])
            tmp3 = triton_helpers.maximum(_tmp2, tmp1)
            _tmp2 = tl.where(rmask, tmp3, _tmp2)
        tmp2 = triton_helpers.max2(_tmp2, 1)[:, None]
        tl.store(out_ptr0 + (x0), tmp2, None)
op8_op9.snodes[1] =
op9: SchedulerNode(ComputedBuffer)
op9.writes = [MemoryDep('buf9', c0, {c0: 4096}, None)]
op9.unmet_dependencies = 
    [   MemoryDep('buf7', 50272*c0 + c1, {c0: 4096, c1: 50265}, None),
        MemoryDep('buf8', c0, {c0: 4096}, None)]
op9.met_dependencies = []
op9.outputs = [
    buf9: ComputedBuffer
    buf9.layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
    buf9.users = [NodeUser(node=SchedulerNode(name='op10'), can_inplace=False, is_weak=False)]
]
op9.group.device = cuda:0
op9.group.iteration = (4096, 50265)
op9.sizes = ([4096], [50265])
buf7_layout = FixedLayout('cuda', torch.float32, size=[4096, 50268], stride=[50272, 1])
buf8_layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
buf9_layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
class op9_loop_body:
    var_ranges = {z0: 4096, z1: 50265}
    index0 = 50272*z0 + z1
    index1 = z0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('buf7', get_index)
        get_index_1 = self.get_index('index1')
        load_1 = ops.load('buf8', get_index_1)
        sub = ops.sub(load, load_1)
        exp = ops.exp(sub)
        reduction = ops.reduction(torch.float32, torch.float32, 'sum', exp)
        get_index_2 = self.get_index('index1')
        store_reduction = ops.store_reduction('buf9', get_index_2, reduction)
        return store_reduction
op9 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.reduction(
        size_hints=[4096, 65536],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: '*fp32', 3: 'i32', 4: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 2, 'num_reduction': 1, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, in_ptr1, out_ptr0, xnumel, rnumel, XBLOCK : tl.constexpr, RBLOCK : tl.constexpr):
        xnumel = 4096
        rnumel = 50265
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
        xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
        rbase = tl.arange(0, RBLOCK)[None, :]
        x0 = xindex
        tmp1 = tl.load(in_ptr1 + (x0), None, eviction_policy='evict_last')
        _tmp5 = tl.full([XBLOCK, RBLOCK], 0, tl.float32)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r1 = rindex
            tmp0 = tl.load(in_ptr0 + (r1 + (50272*x0)), rmask, eviction_policy='evict_last', other=0.0)
            tmp2 = tmp0 - tmp1
            tmp3 = tl_math.exp(tmp2)
            tmp4 = tl.broadcast_to(tmp3, [XBLOCK, RBLOCK])
            tmp6 = _tmp5 + tmp4
            _tmp5 = tl.where(rmask, tmp6, _tmp5)
        tmp5 = tl.sum(_tmp5, 1)[:, None]
        tl.store(out_ptr0 + (x0), tmp5, None)
op8_op9 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.reduction(
        size_hints=[4096, 65536],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*fp32', 2: '*fp32', 3: 'i32', 4: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3), equal_to_1=())]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 2, 'num_reduction': 2, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, out_ptr0, out_ptr1, xnumel, rnumel, XBLOCK : tl.constexpr, RBLOCK : tl.constexpr):
        xnumel = 4096
        rnumel = 50265
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
        xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
        rbase = tl.arange(0, RBLOCK)[None, :]
        x0 = xindex
        _tmp2 = tl.full([XBLOCK, RBLOCK], float("-inf"), tl.float32)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r1 = rindex
            tmp0 = tl.load(in_ptr0 + (r1 + (50272*x0)), rmask, eviction_policy='evict_last', other=0.0)
            tmp1 = tl.broadcast_to(tmp0, [XBLOCK, RBLOCK])
            tmp3 = triton_helpers.maximum(_tmp2, tmp1)
            _tmp2 = tl.where(rmask, tmp3, _tmp2)
        tmp2 = triton_helpers.max2(_tmp2, 1)[:, None]
        tl.store(out_ptr0 + (x0), tmp2, None)
        _tmp8 = tl.full([XBLOCK, RBLOCK], 0, tl.float32)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r1 = rindex
            tmp4 = tl.load(in_ptr0 + (r1 + (50272*x0)), rmask, eviction_policy='evict_last', other=0.0)
            tmp5 = tmp4 - tmp2
            tmp6 = tl_math.exp(tmp5)
            tmp7 = tl.broadcast_to(tmp6, [XBLOCK, RBLOCK])
            tmp9 = _tmp8 + tmp7
            _tmp8 = tl.where(rmask, tmp9, _tmp8)
        tmp8 = tl.sum(_tmp8, 1)[:, None]
        tl.store(out_ptr1 + (x0), tmp8, None)


op10_op11_op12: FusedSchedulerNode(SchedulerNode,SchedulerNode,SchedulerNode)
op10_op11_op12.writes = 
    [   MemoryDep('buf10', 0, {}, None),
        MemoryDep('buf11', 0, {}, None),
        MemoryDep('buf12', 0, {}, None)]
op10_op11_op12.unmet_dependencies = 
    [   MemoryDep('buf7', 50272*c0 + tmp8, {c0: 4096}, None),
        MemoryDep('buf8', c0, {c0: 4096}, None),
        MemoryDep('buf9', c0, {c0: 4096}, None)]
op10_op11_op12.met_dependencies = [MemoryDep('arg7_1', c0, {c0: 4096}, None)]
op10_op11_op12.outputs = [
    buf10: ComputedBuffer
    buf10.layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
    buf10.users = [NodeUser(node=SchedulerNode(name='op12'), can_inplace=True, is_weak=False)]
    buf11: ComputedBuffer
    buf11.layout = FixedLayout('cuda', torch.int64, size=[], stride=[])
    buf11.users = [NodeUser(node=SchedulerNode(name='op12'), can_inplace=True, is_weak=False)]
    buf12: ComputedBuffer
    buf12.layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
    buf12.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
]
op10_op11_op12.snodes[0] =
op10: SchedulerNode(ComputedBuffer)
op10.writes = [MemoryDep('buf10', 0, {}, None)]
op10.unmet_dependencies = 
    [   MemoryDep('buf7', 50272*c0 + tmp8, {c0: 4096}, None),
        MemoryDep('buf8', c0, {c0: 4096}, None),
        MemoryDep('buf9', c0, {c0: 4096}, None)]
op10.met_dependencies = [MemoryDep('arg7_1', c0, {c0: 4096}, None)]
op10.outputs = [
    buf10: ComputedBuffer
    buf10.layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
    buf10.users = [NodeUser(node=SchedulerNode(name='op12'), can_inplace=True, is_weak=False)]
]
op10.group.device = cuda:0
op10.group.iteration = (1, 4096)
op10.sizes = ([], [4096])
arg7_1_layout = FixedLayout('cuda', torch.int64, size=[4, 1024], stride=[1024, 1])
buf7_layout = FixedLayout('cuda', torch.float32, size=[4096, 50268], stride=[50272, 1])
buf8_layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
buf9_layout = FixedLayout('cuda', torch.float32, size=[4096, 1], stride=[1, 4096])
buf10_layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
class op10_loop_body:
    var_ranges = {z0: 4096}
    index0 = z0
    index1 = indirect0 + 50272*z0
    index2 = 0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('arg7_1', get_index)
        constant = ops.constant(-100, torch.int64)
        ne = ops.ne(load, constant)
        get_index_1 = self.get_index('index0')
        load_1 = ops.load('arg7_1', get_index_1)
        constant_1 = ops.constant(-100, torch.int64)
        ne_1 = ops.ne(load_1, constant_1)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('arg7_1', get_index_2)
        constant_2 = ops.constant(0, torch.int64)
        where = ops.where(ne_1, load_2, constant_2)
        set_indirect0 = self.set_indirect0(where)
        get_index_3 = self.get_index('index1')
        load_3 = ops.load('buf7', get_index_3)
        get_index_4 = self.get_index('index0')
        load_4 = ops.load('buf8', get_index_4)
        sub = ops.sub(load_3, load_4)
        get_index_5 = self.get_index('index0')
        load_5 = ops.load('buf9', get_index_5)
        log = ops.log(load_5)
        sub_1 = ops.sub(sub, log)
        neg = ops.neg(sub_1)
        constant_3 = ops.constant(0.0, torch.float32)
        where_1 = ops.where(ne, neg, constant_3)
        reduction = ops.reduction(torch.float32, torch.float32, 'sum', where_1)
        get_index_6 = self.get_index('index2')
        store_reduction = ops.store_reduction('buf10', get_index_6, reduction)
        return store_reduction
op10 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.reduction(
        size_hints=[1, 4096],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*i64', 1: '*fp32', 2: '*fp32', 3: '*fp32', 4: '*fp32', 5: 'i32', 6: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {5: 1}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3, 4, 6), equal_to_1=(5,))]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 3, 'num_reduction': 1, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, in_ptr1, in_ptr2, in_ptr3, out_ptr0, xnumel, rnumel, XBLOCK : tl.constexpr, RBLOCK : tl.constexpr):
        xnumel = 1
        rnumel = 4096
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
        xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
        rbase = tl.arange(0, RBLOCK)[None, :]
        _tmp20 = tl.full([XBLOCK, RBLOCK], 0, tl.float32)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r0 = rindex
            tmp0 = tl.load(in_ptr0 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp11 = tl.load(in_ptr2 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp13 = tl.load(in_ptr3 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp1 = tl.full([1, 1], -100, tl.int64)
            tmp2 = tmp0 != tmp1
            tmp3 = tl.full([1, 1], 0, tl.int64)
            tmp4 = tl.where(tmp2, tmp0, tmp3)
            tmp5 = tl.full([XBLOCK, RBLOCK], 50265, tl.int32)
            tmp6 = tmp4 + tmp5
            tmp7 = tmp4 < 0
            tmp8 = tl.where(tmp7, tmp6, tmp4)
            tl.device_assert(((0 <= tmp8) & (tmp8 < 50265)) | ~(rmask), "index out of bounds: 0 <= tmp8 < 50265")
            tmp10 = tl.load(in_ptr1 + (tmp8 + (50272*r0)), rmask, eviction_policy='evict_last', other=0.0)
            tmp12 = tmp10 - tmp11
            tmp14 = tl_math.log(tmp13)
            tmp15 = tmp12 - tmp14
            tmp16 = -tmp15
            tmp17 = 0.0
            tmp18 = tl.where(tmp2, tmp16, tmp17)
            tmp19 = tl.broadcast_to(tmp18, [XBLOCK, RBLOCK])
            tmp21 = _tmp20 + tmp19
            _tmp20 = tl.where(rmask, tmp21, _tmp20)
        tmp20 = tl.sum(_tmp20, 1)[:, None]
        tl.store(out_ptr0 + (tl.full([XBLOCK, 1], 0, tl.int32)), tmp20, None)
op10_op11_op12.snodes[1] =
op11: SchedulerNode(ComputedBuffer)
op11.writes = [MemoryDep('buf11', 0, {}, None)]
op11.unmet_dependencies = []
op11.met_dependencies = [MemoryDep('arg7_1', c0, {c0: 4096}, None)]
op11.outputs = [
    buf11: ComputedBuffer
    buf11.layout = FixedLayout('cuda', torch.int64, size=[], stride=[])
    buf11.users = [NodeUser(node=SchedulerNode(name='op12'), can_inplace=True, is_weak=False)]
]
op11.group.device = cuda:0
op11.group.iteration = (1, 4096)
op11.sizes = ([], [4096])
arg7_1_layout = FixedLayout('cuda', torch.int64, size=[4, 1024], stride=[1024, 1])
buf11_layout = FixedLayout('cuda', torch.int64, size=[], stride=[])
class op11_loop_body:
    var_ranges = {z0: 4096}
    index0 = z0
    index1 = 0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('arg7_1', get_index)
        constant = ops.constant(-100, torch.int64)
        ne = ops.ne(load, constant)
        to_dtype = ops.to_dtype(ne, torch.int64, src_dtype = torch.bool)
        reduction = ops.reduction(torch.int64, torch.int64, 'sum', to_dtype)
        get_index_1 = self.get_index('index1')
        store_reduction = ops.store_reduction('buf11', get_index_1, reduction)
        return store_reduction
op11 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.reduction(
        size_hints=[1, 4096],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*i64', 1: '*i64', 2: 'i32', 3: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {2: 1}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 3), equal_to_1=(2,))]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': [], 'no_x_dim': False, 'num_load': 1, 'num_reduction': 1, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_ptr0, out_ptr0, xnumel, rnumel, XBLOCK : tl.constexpr, RBLOCK : tl.constexpr):
        xnumel = 1
        rnumel = 4096
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
        xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
        rbase = tl.arange(0, RBLOCK)[None, :]
        _tmp5 = tl.full([XBLOCK, RBLOCK], 0, tl.int64)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r0 = rindex
            tmp0 = tl.load(in_ptr0 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp1 = tl.full([1, 1], -100, tl.int64)
            tmp2 = tmp0 != tmp1
            tmp3 = tmp2.to(tl.int64)
            tmp4 = tl.broadcast_to(tmp3, [XBLOCK, RBLOCK])
            tmp6 = _tmp5 + tmp4
            _tmp5 = tl.where(rmask, tmp6, _tmp5)
        tmp5 = tl.sum(_tmp5, 1)[:, None]
        tl.store(out_ptr0 + (tl.full([XBLOCK, 1], 0, tl.int32)), tmp5, None)
op10_op11_op12.snodes[2] =
op12: SchedulerNode(ComputedBuffer)
op12.writes = [MemoryDep('buf12', 0, {}, None)]
op12.unmet_dependencies = [MemoryDep('buf10', 0, {}, None), MemoryDep('buf11', 0, {}, None)]
op12.met_dependencies = []
op12.outputs = [
    buf12: ComputedBuffer
    buf12.layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
    buf12.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
]
op12.group.device = cuda:0
op12.group.iteration = (1, 1)
op12.sizes = ([], [])
buf10_layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
buf11_layout = FixedLayout('cuda', torch.int64, size=[], stride=[])
buf12_layout = FixedLayout('cuda', torch.float32, size=[], stride=[])
class op12_loop_body:
    var_ranges = {}
    index0 = 0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('buf10', get_index)
        get_index_1 = self.get_index('index0')
        load_1 = ops.load('buf11', get_index_1)
        to_dtype = ops.to_dtype(load_1, torch.float32, src_dtype = torch.int64)
        truediv = ops.truediv(load, to_dtype)
        get_index_2 = self.get_index('index0')
        store = ops.store('buf12', get_index_2, truediv, None)
        return store
op12 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.pointwise(
        size_hints=[1], 
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*i64', 2: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {2: 1}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1), equal_to_1=(2,))]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': ['in_out_ptr0'], 'no_x_dim': False, 'num_load': 2, 'num_reduction': 0, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False},
        min_elem_per_thread=0
    )
    @triton.jit
    def triton_(in_out_ptr0, in_ptr0, xnumel, XBLOCK : tl.constexpr):
        xnumel = 1
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:]
        xmask = tl.full([XBLOCK], True, tl.int1)
        tmp0 = tl.load(in_out_ptr0 + (0))
        tmp1 = tl.broadcast_to(tmp0, [XBLOCK])
        tmp2 = tl.load(in_ptr0 + (0))
        tmp3 = tl.broadcast_to(tmp2, [XBLOCK])
        tmp4 = tmp3.to(tl.float32)
        tmp5 = tmp1 / tmp4
        tl.store(in_out_ptr0 + (tl.full([XBLOCK], 0, tl.int32)), tmp5, None)
op10_op11_op12 Triton code:
    import triton
    import triton.language as tl
    from triton.compiler.compiler import AttrsDescriptor

    from torch._inductor.runtime import triton_helpers, triton_heuristics
    from torch._inductor.runtime.triton_helpers import libdevice, math as tl_math
    from torch._inductor.runtime.hints import AutotuneHint, ReductionHint, TileHint, instance_descriptor, DeviceProperties

    @triton_heuristics.reduction(
        size_hints=[1, 4096],
        reduction_hint=ReductionHint.INNER,
        filename=__file__,
        triton_meta={'signature': {0: '*fp32', 1: '*i64', 2: '*fp32', 3: '*fp32', 4: '*fp32', 5: 'i32', 6: 'i32'}, 'device': DeviceProperties(type='cuda', index=0, cc=90, major=9, regs_per_multiprocessor=65536, max_threads_per_multi_processor=2048, multi_processor_count=132), 'constants': {5: 1}, 'configs': [AttrsDescriptor(divisible_by_16=(0, 1, 2, 3, 4, 6), equal_to_1=(5,))]},
        inductor_meta={'autotune_hints': set(), 'kernel_name': 'Placeholder.DESCRIPTIVE_NAME', 'mutated_arg_names': ['in_out_ptr0'], 'no_x_dim': False, 'num_load': 3, 'num_reduction': 2, 'backend_hash': 'AF2498D67158CAADADFFD49D59358CB8F5E4B1FCD1FBD49EE9B7C2D9E5D02859', 'are_deterministic_algorithms_enabled': False, 'assert_indirect_indexing': True, 'autotune_local_cache': True, 'autotune_pointwise': True, 'autotune_remote_cache': None, 'force_disable_caches': False, 'dynamic_scale_rblock': True, 'max_autotune': False, 'max_autotune_pointwise': False, 'min_split_scan_rblock': 256, 'spill_threshold': 16, 'store_cubin': False}
    )
    @triton.jit
    def triton_(in_out_ptr0, in_ptr0, in_ptr1, in_ptr2, in_ptr3, xnumel, rnumel, XBLOCK : tl.constexpr, RBLOCK : tl.constexpr):
        xnumel = 1
        rnumel = 4096
        xoffset = tl.program_id(0) * XBLOCK
        xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
        xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
        rbase = tl.arange(0, RBLOCK)[None, :]
        _tmp20 = tl.full([XBLOCK, RBLOCK], 0, tl.float32)
        _tmp24 = tl.full([XBLOCK, RBLOCK], 0, tl.int64)
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            r0 = rindex
            tmp0 = tl.load(in_ptr0 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp11 = tl.load(in_ptr2 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp13 = tl.load(in_ptr3 + (r0), rmask, eviction_policy='evict_last', other=0.0)
            tmp1 = tl.full([1, 1], -100, tl.int64)
            tmp2 = tmp0 != tmp1
            tmp3 = tl.full([1, 1], 0, tl.int64)
            tmp4 = tl.where(tmp2, tmp0, tmp3)
            tmp5 = tl.full([XBLOCK, RBLOCK], 50265, tl.int32)
            tmp6 = tmp4 + tmp5
            tmp7 = tmp4 < 0
            tmp8 = tl.where(tmp7, tmp6, tmp4)
            tl.device_assert(((0 <= tmp8) & (tmp8 < 50265)) | ~(rmask), "index out of bounds: 0 <= tmp8 < 50265")
            tmp10 = tl.load(in_ptr1 + (tmp8 + (50272*r0)), rmask, eviction_policy='evict_last', other=0.0)
            tmp12 = tmp10 - tmp11
            tmp14 = tl_math.log(tmp13)
            tmp15 = tmp12 - tmp14
            tmp16 = -tmp15
            tmp17 = 0.0
            tmp18 = tl.where(tmp2, tmp16, tmp17)
            tmp19 = tl.broadcast_to(tmp18, [XBLOCK, RBLOCK])
            tmp21 = _tmp20 + tmp19
            _tmp20 = tl.where(rmask, tmp21, _tmp20)
            tmp22 = tmp2.to(tl.int64)
            tmp23 = tl.broadcast_to(tmp22, [XBLOCK, RBLOCK])
            tmp25 = _tmp24 + tmp23
            _tmp24 = tl.where(rmask, tmp25, _tmp24)
        tmp20 = tl.sum(_tmp20, 1)[:, None]
        tmp24 = tl.sum(_tmp24, 1)[:, None]
        tmp26 = tmp24.to(tl.float32)
        tmp27 = tmp20 / tmp26
        tl.debug_barrier()
        tl.store(in_out_ptr0 + (tl.full([XBLOCK, 1], 0, tl.int32)), tmp27, None)


